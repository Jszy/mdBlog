## 异步I/O
我们时常提到node是单线程的，这里的单线程仅仅只是javascript执行在单线程中罢了。在node中，无论是linux还是window平台，内部完成I/O任务的另有线程池。  
nodejs提供了libuv作为抽象封装层，使得所有平台兼容的判断都由这一层来完成，并保证上层的node与下层自定义线程池及IOCP之间各自独立。
```txt
        ++++++++++++++++++++++++++++++++
        +             nodejs           +
        ++++++++++++++++++++++++++++++++
                        |
        ++++++++++++++++++++++++++++++++
        +             libuv            +
        ++++++++++++++++++++++++++++++++
                        |
        ++++++++++++++++++++++++++++++++
        +    linux          windows    +
        +  自定义线程池        IOCP     +
        ++++++++++++++++++++++++++++++++
```
#### 回调函数实现的本质
node自身的执行模型——事件循环，正是它使得回调函数十分普遍。  
在进程启动时，node会创建一个类似while(true)的循环，每执行一次循环体的过程————Tick.
```
每个Tick的过程，就是查看是否有事件待处理。如果有，就取出事件及其相关的回调函数。
如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出出进程。
```
#### Tick的观察者
每个事件循环中，有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。  
在windows下，这个循环基于IOCP创建，而在linux下则基于多线程创建。
#### 请求对象
javascript发起回调之后，调用node核心模块，核心模块调用C++内建模块，内建模块通过libuv进行判断，并创建了`请求对象`。  
请求对象包含了javascript层传入的参数和当前方法  
对象包装完毕后，会被推进到线程池中等待执行。  
至此，javascript调用立即返回，由javascript层面发起的异步调用的第一阶段就此结束。  

```
javascript线程可以继续执行当前任务的后续操作。
当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到javascript线程的后续执行
如此达到了异步的目的。
```
